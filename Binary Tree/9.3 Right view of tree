[Preorder,inorder,postorder] are depth first search
Level order traversal is breadth first search

Approach 1 :- it can be done using level order traversal in which we write all elements presents in a particular level(from left to right)
then the element at the end will be the element seen from the right view and the first elemnt is the elemnt seen from the left view. this 
approach is not implememted
 we have used depth search approach in which root will always be  the answer and we first visit the right subtree


https://www.geeksforgeeks.org/print-right-view-binary-tree-2/

https://www.techiedelight.com/print-right-view-binary-tree/

class Node{
    int data;
    Node left,right;
    Node(int item){
        data=item;
        left=right=null;
    }
}
class Max_level{
    static int max_level;

}
class BinaryTree {
    static Node root;
    static Max_level max = new Max_level();

   static void rightViewUtil(Node node, int level, Max_level max_leveli) {
        if (node == null) {
            return;
        }
        if (max_leveli.max_level < level) {
            System.out.print(node.data+" ");
            max_leveli.max_level = level;
        }
        rightViewUtil(node.right, level + 1, max_leveli);
        rightViewUtil(node.left, level + 1, max_leveli);
    }

    static void rightView() {
        rightView(root);
    }

    static void rightView(Node node) {
        rightViewUtil(node, 1, max);
    }




    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.root.right.left = new Node(6);
        tree.root.right.right = new Node(7);
        tree.root.right.left.right = new Node(8);
        tree.rightView();


    }
}



Another solution  https://www.techiedelight.com/print-right-view-binary-tree/


import java.util.concurrent.atomic.AtomicInteger;

// Data structure to store a Binary Tree node
class Node
{
	int key;
	Node left = null, right = null;

	Node(int key) {
		this.key = key;
	}
}

class Main {

	// Recursive function to print right view of given binary tree
	public static void rightView(Node root, int level, AtomicInteger lastLevel)
	{
		// base case: empty tree
		if (root == null) {
			return;
		}

		// if current node is last node of current level
		if (lastLevel.get() < level)
		{
			// print the node's data
			System.out.print(root.key + " ");

			// update last level to current level
			lastLevel.set(level);
		}

		// recur for right and left subtree by increasing level by 1
		rightView(root.right, level + 1, lastLevel);
		rightView(root.left, level + 1, lastLevel);
	}

	// Function to print right view of given binary tree
	public static void rightView(Node root)
	{
		// Using AtomicBoolean as Integer is passed by value in Java
		AtomicInteger lastLevel = new AtomicInteger(0);
		rightView(root, 1, lastLevel);
	}

	// main function
	public static void main(String[] args)
	{
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.right = new Node(4);
		root.right.left = new Node(5);
		root.right.right = new Node(6);
		root.right.left.left = new Node(7);
		root.right.left.right = new Node(8);

		rightView(root);
	}
}
